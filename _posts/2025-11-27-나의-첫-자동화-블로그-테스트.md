---
layout: post
title:  "나의 첫 자동화 블로그 테스트"
date:   2025-11-27 10:21:43 +0900
categories: [DevLog]
---

Flutter와 Dart 전문가로서, 이 에러가 발생하는 컴퓨터 공학적 배경과 Dart 컴파일러의 관점에서 아주 상세하게 설명해 드리겠습니다.

이 에러를 완벽하게 이해하려면 **"컴파일 타임(Compile-time)"**과 **"런타임(Run-time)"**의 차이를 명확히 알아야 합니다.

1. 핵심 개념: 컴파일 타임 vs. 런타임
컴파일 타임 (Compile-time): 개발자가 코드를 작성하고 앱을 빌드(Build)하는 시점입니다. 앱이 실행되기 전입니다. 컴파일러는 코드를 기계어로 번역하면서 최적화를 수행합니다.

런타임 (Run-time): 사용자가 앱을 켜서 실제로 사용하는 시점입니다. 코드가 한 줄 한 줄 실행되면서 값이 계산되고 메모리에 올라갑니다.

2. switch-case의 엄격한 규칙
Dart(그리고 C, Java 등 많은 언어)에서 전통적인 switch 문의 case 레이블은 **"변하지 않는 절대적인 값(상수)"**이어야 한다는 규칙이 있습니다.

Dart

switch (variable) {
  case "apple": // OK ("apple"은 변하지 않는 문자열 리터럴)
  case 10:      // OK (10은 변하지 않는 숫자)
}
컴파일러는 이 규칙 덕분에 switch 문을 매우 효율적인 "점프 테이블(Jump Table)" 방식으로 최적화할 수 있습니다. 즉, 하나하나 비교하는 게 아니라, 값이 들어오면 바로 해당 위치로 이동할 수 있게 미리 지도를 그려놓는 것입니다.

이 지도를 그리려면, 앱이 실행되기도 전에(컴파일 타임에) case 옆에 있는 값이 무엇인지 100% 확정되어 있어야 합니다.

3. 왜 .name은 상수가 아닐까?
여기서 직관과 실제 작동 방식의 괴리가 발생합니다.

개발자의 생각: "ErrorType.connectErr는 Enum이니까 안 변하잖아? 그리고 .name도 당연히 문자열 'connectErr'겠지. 그러니까 이건 상수야!"

컴파일러의 생각: "ErrorType.connectErr는 상수 객체가 맞습니다. 하지만 .name은 이 객체 안에 들어있는 속성(Property)에 접근하는 행위입니다. 속성 값을 꺼내오는 건 코드가 실행되어야(런타임) 알 수 있는 일입니다."

Dart에서 object.property (점 연산자)를 사용하여 값에 접근하는 것은 기술적으로 Getter 함수를 호출하는 것과 같습니다.

ErrorType.connectErr: 상수 (메모리에 고정된 주소)

.name: "이 객체의 이름표를 읽어와라"라는 명령(Action)

switch 문의 case는 "명령의 결과값"을 기다려주지 않습니다. 오직 "이미 적혀있는 값"만 받습니다. 그래서 컴파일러는 "나는 지금 지도를 그려야 하는데, .name 값을 알려면 앱을 실행해봐야 하잖아? 난 못 해!" 라며 에러(const_eval_property_access)를 뱉는 것입니다.

4. 시각적 비유
Enum (ErrorType.A): 박물관에 전시된 **'돌'**입니다. 절대 변하지 않습니다.

Enum.name (ErrorType.A.name): 큐레이터가 그 돌을 보고 "이 돌의 이름은 A입니다"라고 말하는 행위입니다.

switch-case는 "돌" 그 자체(case ErrorType.A)는 받아들일 수 있습니다. 돌은 미리 갖다 놓을 수 있으니까요. 하지만 "큐레이터의 말"(case ErrorType.A.name)은 받아들일 수 없습니다. 큐레이터가 언제 말할지, 뭐라고 말할지는 상황이 닥쳐야(런타임) 알 수 있기 때문입니다.

5. 요약 및 해결
결국 이 에러는 **"앱이 실행되기 전에 값을 확정할 수 있는가?"**에 대한 컴파일러의 엄격한 기준 때문에 발생합니다.

❌ 안 되는 코드
Dart

case ErrorType.connectErr.name: // 컴파일러: "실행해봐야 값을 알 수 있어. 안 돼."
✅ 해결책 1: if-else 사용 (가장 유연함)
if 문은 런타임에 값을 비교하므로 제약이 없습니다.

Dart

if (next.status == ErrorType.connectErr.name) { ... }
✅ 해결책 2: Dart 3.0 패턴 매칭 (가장 현대적)
Dart 3.0부터는 switch 문이 강력해져서 Enum 자체를 바로 비교할 수 있습니다. (단, 비교 대상(next.status)을 Enum으로 미리 변환해야 합니다.)

Dart

// 문자열을 Enum으로 변환
final errorType = ErrorType.values.byName(next.status); 

switch (errorType) {
  case ErrorType.connectErr: // .name 없이 Enum 자체를 사용 (가능!)
    ...
}
이 설명이 도움이 되셨나요? Dart의 내부 동작 원리를 이해하는 데 도움이 되었기를 바랍니다.
